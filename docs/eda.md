
### 1. 데이터 기본 정보

- **학습 데이터 (train.csv)**
  - 행: 6,995,056개
  - 열: 3개 (ID, URL, label)
  - 결측치: 없음

- **테스트 데이터 (test.csv)**
  - 행: 1,747,689개
  - 열: 2개 (ID, URL)
  - 결측치: 없음


### 2. URL 길이 통계를 분석

학습/테스트 데이터 전체: URL 길이는 평균 27자 정도, 
최대 길이 
학습 데이터   :약 8,396자, 
테스트 데이터 :약 5,797자로 매우 다양

정상 URL: 평균 길이 약 21자, 대부분 짧은 편.
악성 URL: 평균 길이 약 50자, 정상 URL보다 훨씬 길다. 
          최대 길이도 8,396자로 매우 긴 URL이 존재



# 주요 인사이트
1. URL 길이가 중요한 피처가 될 수 있다.
악성 URL의 평균 길이가 정상 URL의 2배 이상
URL 길이가 악성 여부를 판단하는 중요한 단서

2. 데이터 스케일링 필요
URL 길이가 2자부터 8,000자 이상까지 매우 넓은 범위를 가지므로, 이 길이를 모델에 피처로 사용할 때는 **스케일링(Scaling)**이 필요하다고 판단됨.




### 3. URL 파싱 및 호스트/경로 길이 분석

초기 URL 길이 분석만으로는 부족하다고 판단하여, URL을 구성하는 주요 요소인 **호스트(Host)**와 **경로(Path)**의 길이를 추가로 분석했습니다. 이 과정에서 여러 파싱 방법과 기술적 문제를 해결했습니다.

#### 3.1. 파싱 방법 비교
기존 방법 (urllib.parse 단독): urllib.parse만 사용하여 URL을 파싱하는 방법을 시도했으나, http://와 같은 프로토콜이 없는 URL을 제대로 인식하지 못해 호스트 및 경로 길이가 대부분 0으로 잘못 계산되는 문제가 발생했습니다.

개선된 방법 (urlextract + urllib.parse): 이 문제 해결을 위해 urlextract 라이브러리를 도입하여 URL 문자열을 먼저 추출한 후, urllib.parse로 파싱하는 방법을 시도했습니다. 하지만 urlextract가 일부 URL 패턴을 인식하지 못해 여전히 통계값이 0으로 나오는 문제가 있었습니다.

최종 방법 (정규 표현식): urlextract의 한계를 극복하기 위해 **정규 표현식(Regular Expression)**을 사용하여 호스트와 경로를 직접 추출하는 방법을 채택했습니다. 이 방법은 다양한 형태의 URL을 유연하게 파싱하여 정확한 길이를 계산하는 데 성공했습니다.


#### 3.2. 기술적 문제 해결
메모리 부족: 700만 건에 달하는 대용량 데이터를 한 번에 처리할 경우 메모리 부족으로 인해 컨테이너가 중단되는 문제가 발생했습니다.

해결 방안: pandas.read_csv의 chunksize 옵션을 활용하여 데이터를 50만 건씩 청크(Chunk) 단위로 분할하여 처리하는 방식을 적용했습니다. 이로 인해 메모리 과부하를 방지하고 안정적으로 전체 데이터셋을 분석할 수 있었습니다.



#### 3.3. 최종 분석 결과 및 인사이트
정규 표현식 기반의 파싱 및 청크 단위 처리를 통해 얻은 최종 통계는 다음과 같습니다.

호스트 길이 통계:

정상 URL: 평균 18.4, 최대 91

악성 URL: 평균 25.9, 최대 318

인사이트: 악성 URL의 호스트 길이가 정상 URL보다 평균적으로 더 길고, 최대 길이 또한 훨씬 크다는 것을 확인했습니다. 이는 긴 문자열을 사용해 정상 도메인을 모방하려는 피싱 공격의 특징으로 볼 수 있습니다.

경로 길이 통계:

정상 URL: 평균 2.5, 최대 792

악성 URL: 평균 23.9, 최대 8,375


### 인사이트
 악성 URL의 경로 길이가 정상 URL보다 평균적으로 10배 이상 길고, 최대 길이 역시 매우 긴 것으로 나타났습니다. 특히 정상 URL의 50% 이상은 경로가 없는 반면, 악성 URL은 긴 경로를 사용하여 악성 콘텐츠의 위치를 숨기려는 경향이 강하다고 판단됩니다.


### 결론
호스트 길이와 경로 길이는 악성 URL을 탐지하는 데 있어 **매우 중요한 특성(Feature)**이 될 수 있으며, 이 데이터를 활용해 모델 학습 시 성능을 크게 향상시킬 수 있을 것으로 기대됩니다.




# 파싱 완료 및 저장 이후


## 1. 데이터 로드 및 초기 탐색

데이터 파싱 과정을 통해 생성된 `processed_train.parquet` 파일을 로드하여 분석을 시작했습니다. 초기 데이터는 다음과 같은 특징들을 포함하고 있었습니다.

* `URL`: 원본 URL 문자열
* `host`: URL에서 추출된 호스트 정보
* `path`: URL에서 추출된 경로 정보
* `label`: URL의 정상(0) 또는 악성(1) 여부

---

## 2. 특징 공학 (Feature Engineering)

모델의 성능을 향상시키기 위해, 기존 특징을 기반으로 새로운 숫자형 특징들을 추가했습니다.

* **`host_length`**: 호스트의 문자열 길이
* **`path_length`**: 경로의 문자열 길이
* **`special_char_count`**: URL에 포함된 특수 문자의 개수
* **`subdomain_count`**: 호스트에 포함된 하위 도메인 개수

이러한 특징들은 정상 URL과 악성 URL을 구분하는 데 중요한 정보를 제공합니다.

---

## 3. 특징 분포 시각화

생성된 특징들을 히스토그램으로 시각화하여 정상/악성 URL 간의 분포 차이를 비교했습니다.

* **호스트 길이**: 악성 URL이 정상 URL보다 호스트 길이가 약간 더 긴 경향이 있습니다.
* **경로 길이**: 악성 URL은 정상 URL에 비해 경로가 매우 긴 경우가 많아, 피싱이나 멀웨어 다운로드 페이지로 유도하는 복잡한 경로를 사용하는 패턴이 관찰되었습니다.
* **특수 문자 개수**: 악성 URL은 정상 URL에 비해 특수 문자를 약 2배 이상 많이 사용하는 것으로 나타났습니다.
* **하위 도메인 개수**: 악성 URL은 정상 URL보다 하위 도메인 개수가 더 많거나 복잡한 구조를 가지는 경향이 있습니다.

---

## 4. 특징 간 상관관계 분석

히트맵을 통해 모든 숫자형 특징들 간의 상관관계를 분석했습니다.

* `host_length`와 `subdomain_count`는 `0.66`의 비교적 높은 양의 상관관계를 보였습니다.
* `path_length`와 `special_char_count` 또한 `0.66`의 높은 상관관계를 보였습니다.
* `label`과 가장 높은 상관관계를 보인 특징은 `host_length`(`0.36`)였으며, 다른 특징들 또한 유의미한 상관관계를 가졌습니다.

---

## 5. 데이터 불균형 해결

데이터셋의 클래스 분포를 확인한 결과, 정상 URL(0)이 77%, 악성 URL(1)이 22%로 심각한 불균형 상태임을 발견했습니다.

이러한 불균형이 모델 학습에 편향을 줄 수 있다고 판단하여, 소수 클래스인 악성 URL의 샘플 수를 늘리는 **SMOTE(Synthetic Minority Over-sampling Technique)** 기법을 적용했습니다. 그 결과, 두 클래스의 비율을 1:1로 맞춰 균형 잡힌 데이터셋을 준비했습니다.











